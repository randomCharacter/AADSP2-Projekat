/*
 * model3_mod_impl.c
 *
 * This file defines the actual implementation of the functions for 
 * model3_mod.
 */
#include <model3_mod_impl.h>


/////////////////////////////////////////////////////////////////////////////////
// IO buffers
/////////////////////////////////////////////////////////////////////////////////
__memY DSPfract sampleBuffer[MAX_NUM_CHANNEL][BLOCK_SIZE];
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Gains
/////////////////////////////////////////////////////////////////////////////////
__memX DSPfract gain1 = FRACT_NUM(0.63095734448);
__memX DSPfract gain2 = FRACT_NUM(0.63095734448);
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Enable
/////////////////////////////////////////////////////////////////////////////////
__memX DSPint enable = 1;
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Output mode
/////////////////////////////////////////////////////////////////////////////////
mode output_mode = MODE2_0_0;
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Filter coefficients
/////////////////////////////////////////////////////////////////////////////////
__memX DSPfract l_coefs[] = { FRACT_NUM(0.6828), FRACT_NUM(0.68285), FRACT_NUM(0.6828), FRACT_NUM(1.0), FRACT_NUM(0.5657), FRACT_NUM(0.6) };
__memX DSPfract c_coefs[] = { FRACT_NUM(0.9617), FRACT_NUM(-0.9617), FRACT_NUM(0.9617), FRACT_NUM(1.0), FRACT_NUM(-0.9591), FRACT_NUM(0.9287) };
__memX DSPfract ls_coefs[] = { FRACT_NUM(0.4139), FRACT_NUM(0.0), FRACT_NUM(-0.4139), FRACT_NUM(1.0), FRACT_NUM(-0.3192), FRACT_NUM(0.1722) };
__memX DSPfract rs_coefs[] = { FRACT_NUM(0.4139), FRACT_NUM(0.0), FRACT_NUM(-0.4139), FRACT_NUM(1.0), FRACT_NUM(-0.3192), FRACT_NUM(0.1722) };
__memX DSPfract r_coefs[] = { FRACT_NUM(0.9617), FRACT_NUM(-0.9617), FRACT_NUM(0.9617), FRACT_NUM(1.0), FRACT_NUM(-0.9591), FRACT_NUM(0.9287) };
__memX DSPfract lfe_coefs[] = { FRACT_NUM(0.6828), FRACT_NUM(0.68285), FRACT_NUM(0.6828), FRACT_NUM(1.0), FRACT_NUM(0.5657), FRACT_NUM(0.6) };
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// History
/////////////////////////////////////////////////////////////////////////////////
__memY DSPfract l_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract l_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract c_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract c_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract ls_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract ls_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract rs_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract rs_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract r_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract r_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract lfe_x_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };
__memY DSPfract lfe_y_history[2] = { FRACT_NUM(0.0), FRACT_NUM(0.0) };

void processing() {
        DSPint i;
        DSPfract __memY* sampleBuffer_l = sampleBuffer[CH_L];
        DSPfract __memY* sampleBuffer_r = sampleBuffer[CH_R];
        DSPfract __memY* sampleBuffer_c = sampleBuffer[CH_C];
        DSPfract __memY* sampleBuffer_ls = sampleBuffer[CH_LS];
        DSPfract __memY* sampleBuffer_rs = sampleBuffer[CH_RS];
        DSPfract __memY* sampleBuffer_lfe = sampleBuffer[CH_LFE];

        for (i = 0; i < BLOCK_SIZE; i++) {
                if (output_mode != MODE2_0_0) {
                        *sampleBuffer_c = second_order_IIR(gain1 * *sampleBuffer_l, c_coefs, c_x_history, c_y_history);
                        *sampleBuffer_ls = second_order_IIR(gain1 * *sampleBuffer_l, ls_coefs, ls_x_history, ls_y_history);
                        *sampleBuffer_rs = second_order_IIR(gain2 * *sampleBuffer_l, rs_coefs, rs_x_history, rs_y_history);
                }
                if (output_mode == MODE3_2_1) {
                        *sampleBuffer_lfe = second_order_IIR(gain2 * *sampleBuffer_l, lfe_coefs, lfe_x_history, lfe_y_history);
                }
                *sampleBuffer_r = second_order_IIR(gain2 * *sampleBuffer_l, r_coefs, r_x_history, r_y_history);
                *sampleBuffer_l = second_order_IIR(gain1 * *sampleBuffer_l, l_coefs, l_x_history, l_y_history);

                sampleBuffer_l++;
                sampleBuffer_r++;
                sampleBuffer_c++;
                sampleBuffer_ls++;
                sampleBuffer_rs++;
                sampleBuffer_lfe++;
        }
}


/*
 * It is a good practice to make MCV shadow. That way host changes
 * are less likely to produce inconsistent state
 */
__memY mcv_t model3_mod_mcv_HOST = MCV_INITIAL_VALUES;
__memY mcv_t model3_mod_mcv;

void __fg_call model3_mod_preKickstart(__memY void * mif_ptr)
{
	WAVREAD_HANDLE * wav_in;
	WAVWRITE_HANDLE * wav_out;

	char WavInputName[256];
	char WavOutputName[256];

	int nChannels;
	int bitsPerSample;
	int sampleRate;
	int iNumSamples;
}

void __fg_call model3_mod_postKickstart(void)
{
	// <your code here>
}

void __fg_call model3_mod_timer(void)
{
	// <your code here>
}

void __fg_call model3_mod_frame(void)
{
	// <your code here>
}

void __fg_call model3_mod_brick(void)
{
	int i;
	int j;
	int k;
	int sample;
	int bound = iNumSamples/BLOCK_SIZE;

	for(i=0; i< bound; i++)
	{
		for(j=0; j<BLOCK_SIZE; j++)
		{
			for(k=0; k<nChannels; k++)
			{
				sample = cl_wavread_recvsample(wav_in);
				sampleBuffer[k][j] = rbits(sample);
			}
		}

		// Do processing...
		//-------------------------------------------------
		if (enable) {
			processing();
		}
		//-------------------------------------------------

		for(j=0; j<BLOCK_SIZE; j++)
		{
			for(k=0; k<CHN_NO; k++)
			{
				sample = bitsr(sampleBuffer[k][j]);
				cl_wavwrite_sendsample(wav_out, sample);
			}
		}
	}
}

void __bg_call model3_mod_background(void)
{
	// make a shadow copy of the MCV so that changes won't affect this function
	model3_mod_mcv = model3_mod_mcv_HOST;

	// <your code here>
}

void __fg_call model3_mod_preMallocInit(void)
{
	// <your code here>
}

void __fg_call model3_mod_postMallocInit(void)
{
	// <your code here>
}
